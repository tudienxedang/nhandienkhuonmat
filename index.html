<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Recognition Pro - Ho√†n Ch·ªânh 2024</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <style>
        /* CSS HI·ªÜN ƒê·∫†I T·ªêI ∆ØU */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
        }
        
        body { 
            background: linear-gradient(135deg, #0f172a, #1e293b, #334155);
            color: #f8fafc; 
            min-height: 100vh; 
            padding: 20px;
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px;
        }
        
        /* HEADER HI·ªÜN ƒê·∫†I */
        header { 
            text-align: center; 
            padding: 30px 0; 
            margin-bottom: 40px;
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9));
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        h1 { 
            font-size: 3rem; 
            margin-bottom: 15px; 
            background: linear-gradient(90deg, #60a5fa, #38bdf8, #22d3ee);
            -webkit-background-clip: text; 
            background-clip: text; 
            color: transparent;
            font-weight: 800;
            letter-spacing: -0.5px;
        }
        
        .tech-badge {
            display: inline-block;
            background: linear-gradient(90deg, #f59e0b, #d97706);
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 10px;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }
        
        .subtitle { 
            font-size: 1.3rem; 
            opacity: 0.9; 
            max-width: 800px; 
            margin: 20px auto; 
            color: #cbd5e1;
        }
        
        /* CARD HI·ªÜN ƒê·∫†I */
        .card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        /* DATA MANAGEMENT SECTION - M·ªöI TH√äM */
        .data-management-section {
            border: 2px solid #8b5cf6;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(51, 65, 85, 0.8));
        }
        
        .data-management-title {
            font-size: 1.8rem; 
            margin-bottom: 25px; 
            color: #8b5cf6; 
            padding-bottom: 12px; 
            border-bottom: 2px solid rgba(139, 92, 246, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .data-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .btn-data {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            color: white;
            font-size: 1rem;
            min-width: 160px;
            justify-content: center;
        }
        
        .btn-export { 
            background: linear-gradient(90deg, #10b981, #059669);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3);
        }
        
        .btn-export:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.4);
        }
        
        .btn-import { 
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.3);
        }
        
        .btn-import:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.4);
        }
        
        .btn-clear { 
            background: linear-gradient(90deg, #ef4444, #dc2626);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3);
        }
        
        .btn-clear:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(239, 68, 68, 0.4);
        }
        
        /* UPLOAD SECTION */
        .upload-section {
            border: 2px dashed #3b82f6;
            background: rgba(30, 41, 59, 0.5);
        }
        
        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            margin-top: 15px;
        }
        
        .btn-upload { 
            background: linear-gradient(90deg, #3b82f6, #2563eb);
            color: white; 
            border: none;
            padding: 15px 32px; 
            border-radius: 12px; 
            font-weight: 600; 
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.3);
        }
        
        .btn-upload:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.4);
        }
        
        .upload-btn-wrapper input[type=file] { 
            font-size: 100px; 
            position: absolute; 
            left: 0; 
            top: 0; 
            opacity: 0; 
            cursor: pointer; 
        }
        
        /* STATUS HI·ªÜN ƒê·∫†I */
        .status-container { 
            display: flex; 
            justify-content: center; 
            margin-bottom: 40px; 
        }
        
        .status { 
            display: flex; 
            align-items: center; 
            background: linear-gradient(90deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.9));
            padding: 18px 35px; 
            border-radius: 15px; 
            font-weight: 600; 
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 300px;
            justify-content: center;
        }
        
        .status i { 
            font-size: 1.4rem; 
        }
        
        .status-loading { 
            color: #fbbf24; 
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1));
        }
        
        .status-ready { 
            color: #10b981; 
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1));
        }
        
        .status-error { 
            color: #ef4444; 
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1));
        }
        
        /* LAYOUT HI·ªÜN ƒê·∫†I */
        .main-content { 
            display: grid; 
            grid-template-columns: 1fr 1fr;
            gap: 40px; 
            margin-bottom: 40px; 
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .video-section { 
            position: relative;
        }
        
        .video-container { 
            position: relative; 
            width: 100%; 
            border-radius: 20px; 
            overflow: hidden; 
            background: #000;
            aspect-ratio: 16/9;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }
        
        #video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            display: block; 
        }
        
        #overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }
        
        .results-section { 
            display: flex;
            flex-direction: column;
        }
        
        .section-title { 
            font-size: 1.8rem; 
            margin-bottom: 25px; 
            color: #60a5fa; 
            padding-bottom: 12px; 
            border-bottom: 2px solid rgba(96, 165, 250, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* CONTROLS HI·ªÜN ƒê·∫†I */
        .controls { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 20px; 
            justify-content: center; 
            margin-top: 30px; 
        }
        
        button { 
            padding: 16px 32px; 
            border: none; 
            border-radius: 12px; 
            font-weight: 600; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            transition: all 0.3s ease; 
            color: white;
            font-size: 1.1rem;
            gap: 12px;
            min-width: 180px;
        }
        
        .btn-primary { 
            background: linear-gradient(90deg, #3b82f6, #2563eb);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.3);
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.4);
        }
        
        .btn-secondary { 
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-success { 
            background: linear-gradient(90deg, #10b981, #059669); 
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3);
        }
        
        .btn-success:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.4);
        }
        
        button:disabled { 
            opacity: 0.4; 
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* DETECTION RESULTS HI·ªÜN ƒê·∫†I */
        .detection-results { 
            max-height: 500px; 
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .detection-results::-webkit-scrollbar {
            width: 8px;
        }
        
        .detection-results::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .detection-results::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-radius: 10px;
        }
        
        .face-card { 
            background: rgba(51, 65, 85, 0.5);
            border-radius: 16px; 
            padding: 20px; 
            margin-bottom: 20px; 
            border-left: 5px solid #3b82f6;
            transition: all 0.3s ease;
        }
        
        .face-card:hover {
            background: rgba(71, 85, 105, 0.6);
            transform: translateX(5px);
        }
        
        .face-id { 
            font-weight: 700; 
            color: #60a5fa; 
            margin-bottom: 10px; 
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .face-details { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 15px; 
            margin-top: 15px; 
        }
        
        .face-detail { 
            display: flex; 
            justify-content: space-between; 
            padding: 10px 0; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
        }
        
        .detail-label { 
            font-weight: 600; 
            color: #94a3b8; 
        }
        
        .detail-value { 
            font-weight: 700; 
            color: #f8fafc; 
        }
        
        /* TECH SPECS */
        .tech-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .spec-card {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .spec-icon {
            font-size: 2rem;
            color: #60a5fa;
            margin-bottom: 10px;
        }
        
        .spec-title {
            font-weight: 700;
            color: #f1f5f9;
            margin-bottom: 5px;
        }
        
        .spec-value {
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        /* LOADED PEOPLE */
        .loaded-people { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px; 
            margin-top: 15px; 
        }
        
        .person-tag { 
            background: linear-gradient(90deg, #10b981, #059669);
            color: white; 
            padding: 8px 16px; 
            border-radius: 20px; 
            font-size: 0.9rem; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        /* PERFORMANCE METER */
        .performance-meter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .fps-counter {
            font-weight: 700;
            color: #fbbf24;
            font-size: 1.1rem;
        }
        
        /* FOOTER */
        footer { 
            text-align: center; 
            padding: 30px 0; 
            color: #94a3b8; 
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            margin-top: 40px;
        }
        
        .version-badge {
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }
        
        /* WARNING BANNER */
        .warning-banner {
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.2));
            border-left: 5px solid #f59e0b;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        /* DATA STATUS */
        .data-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* HIDDEN FILE INPUT */
        .hidden-file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="tech-badge">
                <i class="fas fa-microchip"></i> Face-API.js + IndexedDB 2024
            </div>
            <h1><i class="fas fa-robot"></i> H·ªá Th·ªëng Nh·∫≠n Di·ªán Khu√¥n M·∫∑t Pro</h1>
            <p class="subtitle">K·∫øt h·ª£p c√¥ng ngh·ªá AI t·ªëi ∆∞u v·ªõi h·ªá th·ªëng l∆∞u tr·ªØ vƒ©nh vi·ªÖn. D·ªØ li·ªáu kh√¥ng bao gi·ªù m·∫•t!</p>
            
            <div class="tech-specs">
                <div class="spec-card">
                    <div class="spec-icon"><i class="fas fa-bolt"></i></div>
                    <div class="spec-title">30-60 FPS</div>
                    <div class="spec-value">Real-time Performance</div>
                </div>
                <div class="spec-card">
                    <div class="spec-icon"><i class="fas fa-database"></i></div>
                    <div class="spec-title">IndexedDB</div>
                    <div class="spec-value">L∆∞u tr·ªØ vƒ©nh vi·ªÖn</div>
                </div>
                <div class="spec-card">
                    <div class="spec-icon"><i class="fas fa-shield-alt"></i></div>
                    <div class="spec-title">Privacy First</div>
                    <div class="spec-value">100% Offline</div>
                </div>
                <div class="spec-card">
                    <div class="spec-icon"><i class="fas fa-camera"></i></div>
                    <div class="spec-title">Capture & Train</div>
                    <div class="spec-value">Ch·ª•p ·∫£nh tr·ª±c ti·∫øp</div>
                </div>
            </div>
            
            <div class="warning-banner">
                <i class="fas fa-exclamation-triangle" style="color: #f59e0b; font-size: 1.5rem;"></i>
                <div>
                    <strong>L∆∞u √Ω:</strong> D·ªØ li·ªáu ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u v√†o IndexedDB c·ªßa tr√¨nh duy·ªát. Kh√¥ng c·∫ßn h·ªçc l·∫°i m·ªói l·∫ßn ch·∫°y!
                </div>
            </div>
        </header>
        
        <!-- PH·∫¶N QU·∫¢N L√ù D·ªÆ LI·ªÜU - M·ªöI TH√äM -->
        <div class="card data-management-section">
            <h3 class="data-management-title"><i class="fas fa-database"></i> Qu·∫£n l√Ω d·ªØ li·ªáu nh·∫≠n di·ªán</h3>
            <p style="margin: 15px 0; color: #cbd5e1;">
                <i class="fas fa-info-circle"></i> D·ªØ li·ªáu khu√¥n m·∫∑t ƒë∆∞·ª£c l∆∞u vƒ©nh vi·ªÖn v√†o IndexedDB c·ªßa tr√¨nh duy·ªát. C√≥ th·ªÉ export/import ƒë·ªÉ backup ho·∫∑c chia s·∫ª.
            </p>
            
            <div class="data-actions">
                <button class="btn-data btn-export" id="exportData">
                    <i class="fas fa-download"></i> Xu·∫•t d·ªØ li·ªáu
                </button>
                <button class="btn-data btn-import" id="importData">
                    <i class="fas fa-upload"></i> Nh·∫≠p d·ªØ li·ªáu
                </button>
                <button class="btn-data btn-clear" id="clearData">
                    <i class="fas fa-trash"></i> X√≥a t·∫•t c·∫£
                </button>
                <input type="file" id="importFile" accept=".json" class="hidden-file-input">
            </div>
            
            <div class="data-info" id="storageInfo">
                <i class="fas fa-spinner fa-spin"></i> ƒêang ki·ªÉm tra d·ªØ li·ªáu...
            </div>
        </div>
        
        <!-- PH·∫¶N UPLOAD ·∫¢NH -->
        <div class="card upload-section">
            <h3 class="section-title"><i class="fas fa-database"></i> B∆∞·ªõc 1: N·∫°p d·ªØ li·ªáu khu√¥n m·∫∑t</h3>
            <p style="margin: 15px 0; color: #cbd5e1;">
                <i class="fas fa-info-circle"></i> Ch·ªçn th∆∞ m·ª•c ch·ª©a ·∫£nh khu√¥n m·∫∑t. C·∫•u tr√∫c: <strong>T√™n_Ng∆∞·ªùi/hinh_anh.jpg</strong><br>
                V√≠ d·ª•: Th∆∞ m·ª•c "Data" ch·ª©a th∆∞ m·ª•c con "NguyenVanA", b√™n trong c√≥ ·∫£nh c·ªßa A.
            </p>
            <div class="upload-btn-wrapper">
                <button class="btn-upload">
                    <i class="fas fa-folder-plus"></i> Ch·ªçn th∆∞ m·ª•c ·∫£nh
                </button>
                <input type="file" id="folderUpload" webkitdirectory directory multiple accept="image/*">
            </div>
            <div class="data-status" id="dataStatus" style="margin-top: 20px; color: #94a3b8;">
                <i class="fas fa-info-circle"></i> Ch∆∞a c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t. H·ªá th·ªëng ch·ªâ ph√°t hi·ªán khu√¥n m·∫∑t ch∆∞a ƒë·ªãnh danh.
            </div>
            <div class="loaded-people" id="loadedPeople"></div>
        </div>
        
        <div class="status-container">
            <div class="status" id="status">
                <i class="fas fa-sync-alt fa-spin"></i>
                <span>ƒêang kh·ªüi t·∫°o h·ªá th·ªëng AI...</span>
            </div>
        </div>
        
        <!-- PH·∫¶N CH√çNH: CAMERA V√Ä K·∫æT QU·∫¢ -->
        <div class="main-content">
            <div class="card video-section">
                <h2 class="section-title"><i class="fas fa-video"></i> Camera Live</h2>
                <div class="video-container">
                    <video id="video" width="600" height="450" autoplay muted playsinline></video>
                    <canvas id="overlay"></canvas>
                </div>
                
                <div class="performance-meter">
                    <div class="fps-counter">
                        <i class="fas fa-tachometer-alt"></i> FPS: <span id="fpsCounter">0</span>
                    </div>
                    <div id="detectionCount" style="color: #60a5fa;">
                        <i class="fas fa-user"></i> ƒêang ph√°t hi·ªán: <span>0</span> khu√¥n m·∫∑t
                    </div>
                </div>
                
                <div class="controls">
                    <button id="startButton" class="btn-primary" disabled>
                        <i class="fas fa-play-circle"></i> B·∫Øt ƒë·∫ßu nh·∫≠n di·ªán
                    </button>
                    <button id="stopButton" class="btn-secondary" disabled>
                        <i class="fas fa-stop-circle"></i> D·ª´ng nh·∫≠n di·ªán
                    </button>
                    <button id="captureButton" class="btn-success">
                        <i class="fas fa-camera"></i> Ch·ª•p ·∫£nh & H·ªçc
                    </button>
                </div>
            </div>
            
            <div class="card results-section">
                <h2 class="section-title"><i class="fas fa-list-alt"></i> K·∫øt qu·∫£ nh·∫≠n di·ªán</h2>
                <div class="detection-results" id="resultsContainer">
                    <div style="text-align: center; padding: 40px; color: #64748b;">
                        <i class="fas fa-user-circle" style="font-size: 3rem; margin-bottom: 20px;"></i>
                        <p>Ch∆∞a ph√°t hi·ªán khu√¥n m·∫∑t n√†o.</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">B·∫•m "B·∫Øt ƒë·∫ßu nh·∫≠n di·ªán" ƒë·ªÉ kh·ªüi ƒë·ªông camera.</p>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>
                <i class="fas fa-code"></i> H·ªá th·ªëng Face Recognition Pro - T√≠ch h·ª£p IndexedDB & Real-time Detection
                <span class="version-badge">v2024.2</span>
            </p>
            <p style="margin-top: 10px; font-size: 0.8rem;">
                <i class="fas fa-lock"></i> Ho·∫°t ƒë·ªông ho√†n to√†n Offline ‚Ä¢ D·ªØ li·ªáu l∆∞u vƒ©nh vi·ªÖn ‚Ä¢ Kh√¥ng g·ª≠i d·ªØ li·ªáu ƒëi ƒë√¢u
            </p>
        </footer>
    </div>

    <script>
        // ============================================
        // H·ªÜ TH·ªêNG NH·∫¨N DI·ªÜN KHU√îN M·∫∂T HO√ÄN CH·ªàNH
        // K·∫øt h·ª£p giao di·ªán ƒë·∫πp + l∆∞u tr·ªØ vƒ©nh vi·ªÖn
        // ============================================

        // --- BI·∫æN TO√ÄN C·ª§C ---
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const overlayCtx = overlay.getContext('2d');
        const statusElement = document.getElementById('status');
        const resultsContainer = document.getElementById('resultsContainer');
        const dataStatus = document.getElementById('dataStatus');
        const loadedPeopleContainer = document.getElementById('loadedPeople');
        const fpsCounter = document.getElementById('fpsCounter');
        const detectionCount = document.getElementById('detectionCount').querySelector('span');
        const storageInfo = document.getElementById('storageInfo');
        
        // Bi·∫øn h·ªá th·ªëng
        let isDetecting = false;
        let modelsLoaded = false;
        let faceMatcher = null;
        let lastTimestamp = 0;
        let frameCount = 0;
        let fps = 0;
        let detectionOptions = null;
        let db = null; // IndexedDB instance
        
        // C·∫•u h√¨nh
        const MATCH_THRESHOLD = 0.5;
        const MIN_CONFIDENCE = 0.5;
        const INPUT_SIZE = 320;
        
        // C·∫•u h√¨nh IndexedDB
        const DB_NAME = 'FaceRecognitionDB';
        const DB_VERSION = 3; // TƒÉng version ƒë·ªÉ ƒë·∫£m b·∫£o schema m·ªõi
        const STORE_NAME = 'faceDescriptors';

        // ============================================
        // PH·∫¶N 1: INDEXEDDB - L∆ØU TR·ªÆ Vƒ®NH VI·ªÑN
        // ============================================

        // Kh·ªüi t·∫°o IndexedDB
        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = (event) => {
                    console.error("‚ùå L·ªói m·ªü IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("‚úÖ IndexedDB ƒë√£ k·∫øt n·ªëi");
                    
                    // Ki·ªÉm tra d·ªØ li·ªáu ƒë√£ l∆∞u
                    checkStoredData().then(resolve).catch(reject);
                };
                
                request.onupgradeneeded = (event) => {
                    console.log("üîÑ ƒêang n√¢ng c·∫•p IndexedDB...");
                    const db = event.target.result;
                    
                    // T·∫°o object store n·∫øu ch∆∞a c√≥
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'label' });
                        console.log("‚úÖ ƒê√£ t·∫°o object store:", STORE_NAME);
                    }
                };
            });
        }

        // L∆∞u d·ªØ li·ªáu v√†o IndexedDB
        async function saveToIndexedDB(label, descriptors) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error("Database ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o"));
                    return;
                }
                
                // Chuy·ªÉn Float32Array th√†nh Array ƒë·ªÉ l∆∞u
                const descriptorsArray = descriptors.map(desc => {
                    if (desc instanceof Float32Array) {
                        return Array.from(desc);
                    }
                    return desc;
                });
                
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const item = {
                    label: label.toString(),
                    descriptors: descriptorsArray,
                    timestamp: new Date().toISOString(),
                    count: descriptorsArray.length,
                    lastUpdated: new Date().toISOString()
                };
                
                const request = store.put(item);
                
                request.onsuccess = () => {
                    console.log(`‚úÖ ƒê√£ l∆∞u d·ªØ li·ªáu cho: ${label}`);
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error("‚ùå L·ªói l∆∞u d·ªØ li·ªáu:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ IndexedDB
        async function loadFromIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error("Database ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o"));
                    return;
                }
                
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                
                request.onsuccess = (event) => {
                    const items = event.target.result;
                    console.log(`üìä ƒê√£ t·∫£i ${items.length} ng∆∞·ªùi t·ª´ IndexedDB`);
                    resolve(items);
                };
                
                request.onerror = (event) => {
                    console.error("‚ùå L·ªói t·∫£i d·ªØ li·ªáu:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // T·∫£i v√† kh·ªüi t·∫°o FaceMatcher t·ª´ IndexedDB
        async function loadFaceMatcherFromStorage() {
            try {
                const items = await loadFromIndexedDB();
                
                if (items.length === 0) {
                    console.log("üì≠ Kh√¥ng c√≥ d·ªØ li·ªáu ƒë√£ l∆∞u");
                    return null;
                }
                
                console.log(`üîÑ ƒêang t·∫°o FaceMatcher t·ª´ ${items.length} ng∆∞·ªùi...`);
                
                // T·∫°o m·∫£ng LabeledFaceDescriptors t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u
                const labeledDescriptors = [];
                
                for (const item of items) {
                    try {
                        // Chuy·ªÉn ƒë·ªïi Array tr·ªü l·∫°i th√†nh Float32Array
                        const descriptors = item.descriptors.map(arr => {
                            if (Array.isArray(arr)) {
                                return new Float32Array(arr);
                            }
                            return arr;
                        });
                        
                        // T·∫°o LabeledFaceDescriptors ƒë√∫ng c√°ch
                        const labeledFaceDescriptor = new faceapi.LabeledFaceDescriptors(
                            item.label.toString(),
                            descriptors
                        );
                        
                        labeledDescriptors.push(labeledFaceDescriptor);
                        console.log(`   ‚úì ${item.label}: ${descriptors.length} descriptors`);
                        
                    } catch (error) {
                        console.error(`   ‚úó L·ªói x·ª≠ l√Ω ${item.label}:`, error);
                    }
                }
                
                if (labeledDescriptors.length === 0) {
                    console.log("‚ö†Ô∏è Kh√¥ng c√≥ descriptor h·ª£p l·ªá");
                    return null;
                }
                
                // T·∫°o FaceMatcher
                const matcher = new faceapi.FaceMatcher(labeledDescriptors, MATCH_THRESHOLD);
                
                console.log(`‚úÖ ƒê√£ t·∫°o FaceMatcher v·ªõi ${labeledDescriptors.length} ng∆∞·ªùi`);
                return matcher;
                
            } catch (error) {
                console.error("‚ùå L·ªói t·∫°o FaceMatcher t·ª´ storage:", error);
                return null;
            }
        }

        // X√≥a d·ªØ li·ªáu kh·ªèi IndexedDB
        async function clearIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error("Database ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o"));
                    return;
                }
                
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();
                
                request.onsuccess = () => {
                    console.log("‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu");
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error("‚ùå L·ªói x√≥a d·ªØ li·ªáu:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Ki·ªÉm tra v√† hi·ªÉn th·ªã d·ªØ li·ªáu ƒë√£ l∆∞u
        async function checkStoredData() {
            try {
                const items = await loadFromIndexedDB();
                
                // X√≥a container c≈©
                loadedPeopleContainer.innerHTML = '';
                
                if (items && items.length > 0) {
                    // Hi·ªÉn th·ªã th√¥ng tin storage
                    const totalPeople = items.length;
                    const totalImages = items.reduce((sum, item) => sum + (item.count || 0), 0);
                    
                    storageInfo.innerHTML = `
                        <i class="fas fa-check-circle" style="color:#10b981;"></i>
                        ƒê√£ c√≥ d·ªØ li·ªáu <strong>${totalPeople}</strong> ng∆∞·ªùi (<strong>${totalImages}</strong> ·∫£nh) trong b·ªô nh·ªõ
                    `;
                    
                    dataStatus.innerHTML = `
                        <i class="fas fa-check-circle" style="color:#10b981;"></i>
                        ƒê√£ c√≥ d·ªØ li·ªáu ${totalPeople} ng∆∞·ªùi (${totalImages} ·∫£nh) - T·ª± ƒë·ªông l∆∞u
                    `;
                    
                    // Hi·ªÉn th·ªã danh s√°ch ng∆∞·ªùi
                    items.forEach(item => {
                        const tag = document.createElement('span');
                        tag.className = 'person-tag';
                        tag.innerHTML = `
                            <i class="fas fa-user"></i> 
                            ${item.label} 
                            <span style="background:rgba(255,255,255,0.2); padding:2px 6px; border-radius:10px;">
                                ${item.count || 0} ·∫£nh
                            </span>
                        `;
                        loadedPeopleContainer.appendChild(tag);
                    });
                    
                    // T·∫£i FaceMatcher t·ª´ storage
                    faceMatcher = await loadFaceMatcherFromStorage();
                    
                } else {
                    storageInfo.innerHTML = `
                        <i class="fas fa-info-circle"></i>
                        Ch∆∞a c√≥ d·ªØ li·ªáu n√†o ƒë∆∞·ª£c l∆∞u. H√£y upload ·∫£nh ho·∫∑c ch·ª•p t·ª´ camera.
                    `;
                    dataStatus.innerHTML = `
                        <i class="fas fa-info-circle"></i>
                        Ch∆∞a c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t. H·ªá th·ªëng ch·ªâ ph√°t hi·ªán khu√¥n m·∫∑t ch∆∞a ƒë·ªãnh danh.
                    `;
                }
                
            } catch (error) {
                console.error("‚ùå L·ªói ki·ªÉm tra d·ªØ li·ªáu:", error);
                storageInfo.innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="color:#f59e0b;"></i>
                    Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu ƒë√£ l∆∞u
                `;
            }
        }

        // ============================================
        // PH·∫¶N 2: XU·∫§T/NH·∫¨P D·ªÆ LI·ªÜU
        // ============================================

        // Xu·∫•t d·ªØ li·ªáu ra file JSON
        async function exportData() {
            try {
                const items = await loadFromIndexedDB();
                
                if (!items || items.length === 0) {
                    alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!");
                    return;
                }
                
                // Chu·∫©n b·ªã d·ªØ li·ªáu xu·∫•t
                const exportData = {
                    version: "3.0",
                    timestamp: new Date().toISOString(),
                    system: "Face Recognition Pro",
                    people: items.map(item => ({
                        label: item.label,
                        descriptors: item.descriptors,
                        count: item.count,
                        timestamp: item.timestamp,
                        lastUpdated: item.lastUpdated
                    }))
                };
                
                // T·∫°o file JSON
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                // T·∫°o link download
                const downloadLink = document.createElement('a');
                const timestamp = new Date().toLocaleString('vi-VN').replace(/[/:\\]/g, '-');
                downloadLink.download = `face_recognition_data_${timestamp}.json`;
                downloadLink.href = URL.createObjectURL(dataBlob);
                downloadLink.click();
                
                // Cleanup
                setTimeout(() => URL.revokeObjectURL(downloadLink.href), 100);
                
                // Th√¥ng b√°o
                const oldStatus = statusElement.querySelector('span').textContent;
                updateStatus(`ƒê√£ xu·∫•t ${items.length} ng∆∞·ªùi th√†nh c√¥ng!`, 'ready');
                setTimeout(() => updateStatus(oldStatus, 'ready'), 2000);
                
            } catch (error) {
                console.error("‚ùå L·ªói xu·∫•t d·ªØ li·ªáu:", error);
                updateStatus('L·ªói xu·∫•t d·ªØ li·ªáu!', 'error');
                setTimeout(() => updateStatus('H·ªá th·ªëng s·∫µn s√†ng', 'ready'), 2000);
            }
        }

        // Nh·∫≠p d·ªØ li·ªáu t·ª´ file JSON
        async function importData(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        // Ki·ªÉm tra version
                        if (!importedData.version || !importedData.people) {
                            throw new Error("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng");
                        }
                        
                        let importedCount = 0;
                        
                        // Hi·ªÉn th·ªã loading
                        updateStatus('ƒêang import d·ªØ li·ªáu...', 'loading');
                        
                        // Import t·ª´ng ng∆∞·ªùi
                        for (const person of importedData.people) {
                            // ƒê·∫£m b·∫£o descriptors l√† m·∫£ng Float32Array
                            const descriptors = person.descriptors.map(arr => {
                                if (Array.isArray(arr)) {
                                    return new Float32Array(arr);
                                }
                                return arr;
                            });
                            
                            await saveToIndexedDB(person.label, descriptors);
                            importedCount++;
                        }
                        
                        // T·∫£i l·∫°i d·ªØ li·ªáu
                        await checkStoredData();
                        
                        // Th√¥ng b√°o
                        const oldStatus = statusElement.querySelector('span').textContent;
                        updateStatus(`ƒê√£ import ${importedCount} ng∆∞·ªùi!`, 'ready');
                        setTimeout(() => updateStatus(oldStatus, 'ready'), 2000);
                        
                        resolve();
                        
                    } catch (error) {
                        console.error("‚ùå L·ªói import d·ªØ li·ªáu:", error);
                        updateStatus('File kh√¥ng h·ª£p l·ªá!', 'error');
                        setTimeout(() => updateStatus('H·ªá th·ªëng s·∫µn s√†ng', 'ready'), 2000);
                        reject(error);
                    }
                };
                
                reader.onerror = () => {
                    reject(new Error("L·ªói ƒë·ªçc file"));
                };
                
                reader.readAsText(file);
            });
        }

        // ============================================
        // PH·∫¶N 3: T·∫¢I M√î H√åNH V√Ä X·ª¨ L√ù ·∫¢NH
        // ============================================

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i h·ªá th·ªëng
        function updateStatus(msg, type = 'loading') {
            const icon = statusElement.querySelector('i');
            statusElement.querySelector('span').textContent = msg;
            statusElement.className = `status status-${type}`;
            
            switch(type) {
                case 'loading':
                    icon.className = 'fas fa-sync-alt fa-spin';
                    break;
                case 'ready':
                    icon.className = 'fas fa-check-circle';
                    break;
                case 'error':
                    icon.className = 'fas fa-exclamation-circle';
                    break;
            }
        }

        // T·∫£i m√¥ h√¨nh AI
        async function loadModels() {
            try {
                updateStatus('ƒêang t·∫£i m√¥ h√¨nh AI...', 'loading');
                
                // S·ª≠ d·ª•ng CDN tr·ª±c ti·∫øp t·ª´ GitHub
                const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
                
                // T·∫£i c√°c m√¥ h√¨nh song song ƒë·ªÉ tƒÉng t·ªëc
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                    faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
                    faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL)
                ]);
                
                // C·∫•u h√¨nh detection options cho TinyFaceDetector
                detectionOptions = new faceapi.TinyFaceDetectorOptions({
                    inputSize: INPUT_SIZE,
                    scoreThreshold: MIN_CONFIDENCE
                });
                
                modelsLoaded = true;
                document.getElementById('startButton').disabled = false;
                document.getElementById('captureButton').disabled = false;
                
                updateStatus('H·ªá th·ªëng ƒë√£ s·∫µn s√†ng!', 'ready');
                console.log("‚úÖ T·∫•t c·∫£ m√¥ h√¨nh ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng");
                
            } catch (err) {
                console.error("‚ùå L·ªói t·∫£i m√¥ h√¨nh:", err);
                updateStatus('L·ªói t·∫£i m√¥ h√¨nh AI. Vui l√≤ng t·∫£i l·∫°i trang.', 'error');
            }
        }

        // X·ª≠ l√Ω upload ·∫£nh v√† l∆∞u v√†o IndexedDB
        document.getElementById('folderUpload').addEventListener('change', async (e) => {
            if (!modelsLoaded) {
                alert("Vui l√≤ng ƒë·ª£i h·ªá th·ªëng kh·ªüi t·∫°o xong!");
                return;
            }
            
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            updateStatus('ƒêang h·ªçc khu√¥n m·∫∑t t·ª´ ·∫£nh...', 'loading');
            
            // Nh√≥m file theo t√™n th∆∞ m·ª•c (t√™n ng∆∞·ªùi)
            const labeledImages = {};
            
            files.forEach(file => {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length >= 2) {
                    const label = pathParts[pathParts.length - 2];
                    if (!file.type.match('image.*')) return;
                    
                    if (!labeledImages[label]) labeledImages[label] = [];
                    labeledImages[label].push(file);
                }
            });

            const labels = Object.keys(labeledImages);
            loadedPeopleContainer.innerHTML = '';

            if (labels.length === 0) {
                updateStatus('Kh√¥ng t√¨m th·∫•y c·∫•u tr√∫c th∆∞ m·ª•c h·ª£p l·ªá', 'error');
                return;
            }

            // Hi·ªÉn th·ªã ti·∫øn tr√¨nh
            dataStatus.innerHTML = `<div class="loader"></div> ƒêang x·ª≠ l√Ω ${files.length} ·∫£nh...`;
            
            let processedCount = 0;
            let totalDescriptors = 0;
            
            // X·ª≠ l√Ω t·ª´ng ng∆∞·ªùi
            for (const label of labels) {
                const descriptors = [];
                
                for (const imageFile of labeledImages[label]) {
                    try {
                        const img = await faceapi.bufferToImage(imageFile);
                        
                        // Ph√°t hi·ªán khu√¥n m·∫∑t v·ªõi TinyFaceDetector
                        const detection = await faceapi
                            .detectSingleFace(img, detectionOptions)
                            .withFaceLandmarks()
                            .withFaceDescriptor();
                        
                        if (detection) {
                            descriptors.push(detection.descriptor);
                            totalDescriptors++;
                        }
                    } catch (err) {
                        console.log(`L·ªói ƒë·ªçc ·∫£nh c·ªßa ${label}:`, err);
                    }
                }
                
                if (descriptors.length > 0) {
                    // L∆∞u v√†o IndexedDB
                    await saveToIndexedDB(label, descriptors);
                    processedCount++;
                    
                    // Th√™m v√†o giao di·ªán
                    const tag = document.createElement('span');
                    tag.className = 'person-tag';
                    tag.innerHTML = `<i class="fas fa-user"></i> ${label} <span style="background:rgba(255,255,255,0.2); padding:2px 6px; border-radius:10px;">${descriptors.length}</span>`;
                    loadedPeopleContainer.appendChild(tag);
                }
            }

            // T·∫£i l·∫°i FaceMatcher t·ª´ storage
            faceMatcher = await loadFaceMatcherFromStorage();
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            if (processedCount > 0) {
                dataStatus.innerHTML = `
                    <i class="fas fa-check-circle" style="color:#10b981;"></i>
                    ƒê√£ h·ªçc v√† l∆∞u ${processedCount} ng∆∞·ªùi (${totalDescriptors} descriptors)
                `;
                updateStatus('ƒê√£ h·ªçc xong d·ªØ li·ªáu! S·∫µn s√†ng nh·∫≠n di·ªán', 'ready');
            } else {
                dataStatus.innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="color:#f59e0b;"></i>
                    Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t n√†o trong ·∫£nh ƒë√£ t·∫£i
                `;
                updateStatus('Kh√¥ng c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t', 'error');
            }
            
            // Reset input
            e.target.value = '';
        });

        // ============================================
        // PH·∫¶N 4: CAMERA, CH·ª§P ·∫¢NH V√Ä NH·∫¨N DI·ªÜN
        // ============================================

        // Kh·ªüi ƒë·ªông camera
        async function startCamera() {
            try {
                // Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ truy c·∫≠p camera');
                }
                
                // Y√™u c·∫ßu quy·ªÅn truy c·∫≠p camera
                const constraints = {
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // ƒê·ª£i video s·∫µn s√†ng
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        overlay.width = video.videoWidth;
                        overlay.height = video.videoHeight;
                        resolve();
                    };
                    
                    video.onerror = () => {
                        reject(new Error('L·ªói khi t·∫£i video stream'));
                    };
                    
                    // Timeout sau 5 gi√¢y
                    setTimeout(() => {
                        if (!video.videoWidth) {
                            reject(new Error('Timeout khi kh·ªüi ƒë·ªông camera'));
                        }
                    }, 5000);
                });
            } catch (err) {
                console.error("‚ùå L·ªói camera:", err);
                
                // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói th√¢n thi·ªán
                let errorMsg = 'Kh√¥ng th·ªÉ truy c·∫≠p camera. ';
                if (err.name === 'NotAllowedError') {
                    errorMsg += 'Vui l√≤ng cho ph√©p truy c·∫≠p camera.';
                } else if (err.name === 'NotFoundError') {
                    errorMsg += 'Kh√¥ng t√¨m th·∫•y camera.';
                } else {
                    errorMsg += err.message;
                }
                
                updateStatus(errorMsg, 'error');
                throw err;
            }
        }

        // T√≠nh to√°n FPS
        function calculateFPS(timestamp) {
            frameCount++;
            
            if (timestamp >= lastTimestamp + 1000) {
                fps = Math.round((frameCount * 1000) / (timestamp - lastTimestamp));
                frameCount = 0;
                lastTimestamp = timestamp;
                fpsCounter.textContent = fps;
            }
        }

        // Nh·∫≠n di·ªán khu√¥n m·∫∑t
        async function detectFaces() {
            if (!isDetecting || !modelsLoaded) return;

            const startTime = performance.now();
            
            // ƒê·∫£m b·∫£o k√≠ch th∆∞·ªõc overlay kh·ªõp v·ªõi video
            if (overlay.width !== video.videoWidth || overlay.height !== video.videoHeight) {
                overlay.width = video.videoWidth;
                overlay.height = video.videoHeight;
            }
            
            // Ph√°t hi·ªán t·∫•t c·∫£ khu√¥n m·∫∑t trong frame
            const detections = await faceapi
                .detectAllFaces(video, detectionOptions)
                .withFaceLandmarks()
                .withFaceDescriptors()
                .withFaceExpressions()
                .withAgeAndGender();
            
            // Resize detections ƒë·ªÉ kh·ªõp v·ªõi overlay
            const resizedDetections = faceapi.resizeResults(detections, {
                width: video.videoWidth,
                height: video.videoHeight
            });
            
            // X√≥a canvas c≈©
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng khu√¥n m·∫∑t
            detectionCount.textContent = resizedDetections.length;
            
            if (resizedDetections.length > 0) {
                const resultsToDisplay = [];
                
                // V·∫Ω t·ª´ng khu√¥n m·∫∑t
                resizedDetections.forEach((detection, index) => {
                    const box = detection.detection.box;
                    const landmarks = detection.landmarks;
                    const descriptor = detection.descriptor;
                    const expressions = detection.expressions;
                    const age = detection.age;
                    const gender = detection.gender;
                    
                    // X√°c ƒë·ªãnh danh t√≠nh
                    let label = "Unknown";
                    let distance = 1;
                    
                    if (faceMatcher && descriptor) {
                        const bestMatch = faceMatcher.findBestMatch(descriptor);
                        label = bestMatch.label;
                        distance = bestMatch.distance;
                    }
                    
                    // X√°c ƒë·ªãnh m√†u s·∫Øc d·ª±a tr√™n ƒë·ªô tin c·∫≠y
                    const isKnown = label !== "unknown" && label !== "Unknown" && distance < 0.5;
                    const boxColor = isKnown ? '#10b981' : '#ef4444';
                    const labelColor = isKnown ? '#10b981' : '#f59e0b';
                    
                    // V·∫Ω bounding box
                    overlayCtx.strokeStyle = boxColor;
                    overlayCtx.lineWidth = 3;
                    overlayCtx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // V·∫Ω landmarks (68 ƒëi·ªÉm)
                    overlayCtx.fillStyle = '#3b82f6';
                    landmarks.positions.forEach(point => {
                        overlayCtx.beginPath();
                        overlayCtx.arc(point.x, point.y, 2, 0, 2 * Math.PI);
                        overlayCtx.fill();
                    });
                    
                    // V·∫Ω nh√£n v·ªõi background
                    const labelText = isKnown ? 
                        `${label} (${Math.round((1 - distance) * 100)}%)` : 
                        `Ng∆∞·ªùi l·∫°`;
                    
                    // Background cho nh√£n
                    overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    overlayCtx.fillRect(box.x, box.y - 30, 200, 25);
                    
                    // Text nh√£n
                    overlayCtx.fillStyle = labelColor;
                    overlayCtx.font = 'bold 14px Arial';
                    overlayCtx.fillText(labelText, box.x + 5, box.y - 10);
                    
                    // Th√™m bi·ªÉu c·∫£m n·∫øu c√≥
                    if (expressions) {
                        const dominantExpression = Object.entries(expressions)
                            .reduce((max, [emotion, value]) => value > max[1] ? [emotion, value] : max, ['neutral', 0]);
                        
                        overlayCtx.fillStyle = '#94a3b8';
                        overlayCtx.font = '12px Arial';
                        overlayCtx.fillText(
                            `${dominantExpression[0]}: ${Math.round(dominantExpression[1] * 100)}%`,
                            box.x + 5,
                            box.y + box.height + 15
                        );
                    }
                    
                    // Th√™m th√¥ng tin v√†o k·∫øt qu·∫£
                    resultsToDisplay.push({
                        id: index + 1,
                        label: label,
                        isKnown: isKnown,
                        confidence: Math.round((1 - distance) * 100),
                        age: Math.round(age),
                        gender: gender,
                        box: box,
                        expressions: expressions
                    });
                });
                
                updateResultsUI(resultsToDisplay);
            } else {
                updateResultsUI([]);
            }
            
            // T√≠nh FPS
            calculateFPS(startTime);
            
            // L·∫∑p l·∫°i
            if (isDetecting) {
                requestAnimationFrame(detectFaces);
            }
        }

        // Ch·ª•p ·∫£nh t·ª´ camera v√† h·ªçc khu√¥n m·∫∑t - T√çCH H·ª¢P M·ªöI
        document.getElementById('captureButton').addEventListener('click', async () => {
            if (!video.srcObject || !modelsLoaded) {
                alert("Vui l√≤ng b·∫≠t camera tr∆∞·ªõc khi ch·ª•p ·∫£nh!");
                return;
            }
            
            // Hi·ªÉn th·ªã prompt ƒë·ªÉ nh·∫≠p t√™n
            const personName = prompt("Nh·∫≠p t√™n ng∆∞·ªùi trong ·∫£nh:", "NewPerson");
            if (!personName || personName.trim() === "") {
                alert("Vui l√≤ng nh·∫≠p t√™n h·ª£p l·ªá!");
                return;
            }
            
            updateStatus('ƒêang x·ª≠ l√Ω ·∫£nh...', 'loading');
            
            // T·∫°o canvas ƒë·ªÉ ch·ª•p ·∫£nh
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // V·∫Ω video frame v√†o canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            try {
                // Ph√°t hi·ªán khu√¥n m·∫∑t trong ·∫£nh v·ª´a ch·ª•p
                const detection = await faceapi
                    .detectSingleFace(canvas, detectionOptions)
                    .withFaceLandmarks()
                    .withFaceDescriptor();
                
                if (detection) {
                    // L·∫•y descriptor t·ª´ khu√¥n m·∫∑t ph√°t hi·ªán ƒë∆∞·ª£c
                    const descriptor = detection.descriptor;
                    
                    // T·∫£i d·ªØ li·ªáu hi·ªán t·∫°i t·ª´ IndexedDB
                    const items = await loadFromIndexedDB();
                    let existingPerson = items.find(item => item.label === personName);
                    
                    if (existingPerson) {
                        // Ng∆∞·ªùi ƒë√£ t·ªìn t·∫°i, th√™m descriptor m·ªõi
                        const existingDescriptors = existingPerson.descriptors.map(arr => new Float32Array(arr));
                        existingDescriptors.push(descriptor);
                        
                        // C·∫≠p nh·∫≠t v√†o IndexedDB
                        await saveToIndexedDB(personName, existingDescriptors);
                        
                        // C·∫≠p nh·∫≠t giao di·ªán
                        const existingTag = Array.from(loadedPeopleContainer.querySelectorAll('.person-tag'))
                            .find(tag => tag.textContent.includes(personName));
                        if (existingTag) {
                            const countMatch = existingTag.textContent.match(/\((\d+)/);
                            const newCount = countMatch ? parseInt(countMatch[1]) + 1 : 1;
                            existingTag.innerHTML = `
                                <i class="fas fa-user"></i> ${personName} 
                                <span style="background:rgba(255,255,255,0.2); padding:2px 6px; border-radius:10px;">
                                    ${newCount} ·∫£nh
                                </span>
                            `;
                        }
                        
                        updateStatus(`ƒê√£ th√™m ·∫£nh m·ªõi cho ${personName}`, 'ready');
                    } else {
                        // Ng∆∞·ªùi m·ªõi, t·∫°o m·ªõi
                        await saveToIndexedDB(personName, [descriptor]);
                        
                        // Th√™m v√†o giao di·ªán
                        const tag = document.createElement('span');
                        tag.className = 'person-tag';
                        tag.innerHTML = `
                            <i class="fas fa-user"></i> ${personName} 
                            <span style="background:rgba(255,255,255,0.2); padding:2px 6px; border-radius:10px;">
                                1 ·∫£nh
                            </span>
                        `;
                        loadedPeopleContainer.appendChild(tag);
                        
                        updateStatus(`ƒê√£ h·ªçc th√†nh c√¥ng ${personName}`, 'ready');
                    }
                    
                    // T·∫£i l·∫°i FaceMatcher
                    faceMatcher = await loadFaceMatcherFromStorage();
                    
                    // C·∫≠p nh·∫≠t storage info
                    await checkStoredData();
                    
                } else {
                    updateStatus('Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t trong ·∫£nh!', 'error');
                }
                
            } catch (error) {
                console.error("L·ªói x·ª≠ l√Ω ·∫£nh:", error);
                updateStatus('L·ªói x·ª≠ l√Ω ·∫£nh!', 'error');
            }
            
            setTimeout(() => updateStatus('ƒêang nh·∫≠n di·ªán...', 'loading'), 2000);
        });

        // C·∫≠p nh·∫≠t giao di·ªán k·∫øt qu·∫£
        function updateResultsUI(results) {
            if (results.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #64748b;">
                        <i class="fas fa-user-circle" style="font-size: 3rem; margin-bottom: 20px;"></i>
                        <p>Kh√¥ng c√≥ khu√¥n m·∫∑t n√†o ƒë∆∞·ª£c ph√°t hi·ªán.</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            results.forEach((result) => {
                const confidenceColor = result.confidence > 80 ? '#10b981' : 
                                      result.confidence > 60 ? '#f59e0b' : '#ef4444';
                
                // X√°c ƒë·ªãnh bi·ªÉu c·∫£m ch√≠nh
                let dominantExpression = 'neutral';
                let expressionConfidence = 0;
                if (result.expressions) {
                    const entries = Object.entries(result.expressions);
                    const max = entries.reduce((max, [emotion, value]) => 
                        value > max[1] ? [emotion, value] : max, ['neutral', 0]);
                    dominantExpression = max[0];
                    expressionConfidence = Math.round(max[1] * 100);
                }
                
                html += `
                <div class="face-card">
                    <div class="face-id" style="${result.isKnown ? 'color: #10b981;' : 'color: #ef4444;'}">
                        <i class="fas ${result.isKnown ? 'fa-check-circle' : 'fa-question-circle'}"></i>
                        ${result.label}
                        <span style="color: ${confidenceColor}; font-size: 0.9em; margin-left: 10px;">
                            ${result.confidence}%
                        </span>
                    </div>
                    <div class="face-details">
                        <div class="face-detail">
                            <span class="detail-label">Tu·ªïi/Gi·ªõi t√≠nh:</span>
                            <span class="detail-value">${result.age} tu·ªïi, ${result.gender}</span>
                        </div>
                        <div class="face-detail">
                            <span class="detail-label">Bi·ªÉu c·∫£m:</span>
                            <span class="detail-value">${dominantExpression} (${expressionConfidence}%)</span>
                        </div>
                        <div class="face-detail">
                            <span class="detail-label">V·ªã tr√≠:</span>
                            <span class="detail-value">${Math.round(result.box.x)}x${Math.round(result.box.y)}</span>
                        </div>
                        <div class="face-detail">
                            <span class="detail-label">Tr·∫°ng th√°i:</span>
                            <span class="detail-value" style="color: ${result.isKnown ? '#10b981' : '#ef4444'}">
                                ${result.isKnown ? 'ƒê√£ bi·∫øt' : 'Ch∆∞a bi·∫øt'}
                            </span>
                        </div>
                    </div>
                </div>
                `;
            });
            resultsContainer.innerHTML = html;
        }

        // ============================================
        // PH·∫¶N 5: S·ª∞ KI·ªÜN V√Ä KH·ªûI ƒê·ªòNG
        // ============================================

        // S·ª± ki·ªán n√∫t b·∫Øt ƒë·∫ßu/d·ª´ng
        document.getElementById('startButton').addEventListener('click', async () => {
            if (!modelsLoaded) {
                alert("H·ªá th·ªëng AI ch∆∞a s·∫µn s√†ng! Vui l√≤ng ƒë·ª£i.");
                return;
            }
            
            try {
                await startCamera();
                isDetecting = true;
                
                // C·∫≠p nh·∫≠t giao di·ªán
                document.getElementById('startButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('captureButton').disabled = false;
                
                updateStatus('ƒêang nh·∫≠n di·ªán khu√¥n m·∫∑t...', 'loading');
                
                // B·∫Øt ƒë·∫ßu detection loop
                detectFaces();
                
            } catch (err) {
                console.error("L·ªói khi b·∫Øt ƒë·∫ßu nh·∫≠n di·ªán:", err);
                updateStatus('Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông camera', 'error');
                isDetecting = false;
                document.getElementById('startButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            }
        });

        document.getElementById('stopButton').addEventListener('click', () => {
            isDetecting = false;
            
            // D·ª´ng camera stream
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // X√≥a canvas overlay
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            
            // C·∫≠p nh·∫≠t giao di·ªán
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            document.getElementById('captureButton').disabled = true;
            
            detectionCount.textContent = '0';
            fpsCounter.textContent = '0';
            
            updateStatus('ƒê√£ d·ª´ng nh·∫≠n di·ªán', 'ready');
        });

        // S·ª± ki·ªán qu·∫£n l√Ω d·ªØ li·ªáu
        document.getElementById('exportData').addEventListener('click', exportData);
        
        document.getElementById('importData').addEventListener('click', () => {
            document.getElementById('importFile').click();
        });
        
        document.getElementById('importFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    await importData(file);
                } catch (error) {
                    console.error("Import error:", error);
                }
                e.target.value = '';
            }
        });
        
        document.getElementById('clearData').addEventListener('click', async () => {
            if (confirm("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ d·ªØ li·ªáu ƒë√£ h·ªçc?\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!\nTo√†n b·ªô d·ªØ li·ªáu s·∫Ω b·ªã x√≥a vƒ©nh vi·ªÖn.")) {
                try {
                    updateStatus('ƒêang x√≥a d·ªØ li·ªáu...', 'loading');
                    await clearIndexedDB();
                    loadedPeopleContainer.innerHTML = '';
                    faceMatcher = null;
                    await checkStoredData();
                    
                    const oldStatus = statusElement.querySelector('span').textContent;
                    updateStatus('ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu!', 'ready');
                    setTimeout(() => updateStatus(oldStatus, 'ready'), 2000);
                    
                } catch (error) {
                    updateStatus('L·ªói khi x√≥a d·ªØ li·ªáu!', 'error');
                    setTimeout(() => updateStatus('H·ªá th·ªëng s·∫µn s√†ng', 'ready'), 2000);
                }
            }
        });

        // Kh·ªüi ƒë·ªông h·ªá th·ªëng
        async function initializeSystem() {
            try {
                console.log("üöÄ ƒêang kh·ªüi ƒë·ªông h·ªá th·ªëng Face Recognition Pro...");
                
                // 1. Kh·ªüi t·∫°o IndexedDB
                await initIndexedDB();
                
                // 2. T·∫£i m√¥ h√¨nh AI
                await loadModels();
                
                console.log("‚úÖ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng!");
                
            } catch (error) {
                console.error("‚ùå L·ªói kh·ªüi t·∫°o:", error);
                updateStatus('C√≥ l·ªói x·∫£y ra khi kh·ªüi ƒë·ªông h·ªá th·ªëng!', 'error');
            }
        }

        // B·∫Øt ƒë·∫ßu khi trang load
        window.addEventListener('load', initializeSystem);
        
        // X·ª≠ l√Ω l·ªói to√†n c·ª•c
        window.addEventListener('error', (event) => {
            console.error('L·ªói to√†n c·ª•c:', event.error);
        });
    </script>
</body>
</html>
